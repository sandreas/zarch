#!/bin/sh

# define fix config vars
export CONF_FILE="zarch.conf"
PKG_FILE="pkglist.txt"
PKG_AUR_FILE="pkglist_aur.txt"


# pkglist.txt can be overridden with pkglist.txt.local
if [ -f "$PKG_FILE.local" ]; then
  PKG_FILE="$PKG_FILE.local"
fi

# pkglist_aur.txt can be overridden with pkglist_aur.txt.local
if [ -f "$PKG_AUR_FILE.local" ]; then
  PKG_AUR_FILE="$PKG_AUR_FILE.local"
fi

# read pkglist.txt and pkglist_aur.txt
PKG_LIST="$(grep -v '^\s*$\|^\s*#' $PKG_FILE)"
PKG_AUR_LIST="$(grep -v '^\s*$\|^\s*#' $PKG_AUR_FILE)"

# RUN executes and logs a command (e.g. RUN echo "test")
RUN() {
  cmd="$@"
  # echo command before executing it (to show progress)
  echo "$cmd"
  output="$(sh -c "$cmd" 2>&1)"
  returnCode="$?"

  # echo output after all variables have been set to prevent setting return code of echo command
  echo "$output"

  # log command, output and return code
  LOG "$cmd"
  [ "$output" = "" ] || LOG "$output"
  LOG "return code: $returnCode"
  LOG ""


  CHECK_SUCCESS "$returnCode" "$cmd" "$output"
}

# CHECK_SUCCESS checks the success return code of a command (e.g. CHECK_SUCCESS "$?" "echo 'test'")
CHECK_SUCCESS() {
    returnCode="$1"
    cmd="$2"
    output="$3"
    # if command failed, exit program
    if ! [ "$returnCode" = "0" ]; then
      echo "COMMAND FAILED (Code $returnCode):"
      echo "==================================="
      echo "  $cmd"
      echo "  $output"
      echo "==================================="
      exit $returnCode
    fi
}

LOG() {
  if [ "$LOG_FILE" = "" ]; then
    export LOG_FILE
    LOG_FILE="$(basename $0).log"
  fi
  echo "$1" >> "$LOG_FILE"
}


# function to load .env variable by name, example:
# load_env_variable DISK
load_env_variable() {
  variable="$(grep "$1" "$CONF_FILE" | cut -d '=' -f 2 | sed "s/^[\"']\(.*\)[\"'].*$/\1/")"
  return_value="$?"
  echo "$variable"
  return "$return_value"
}

yes_or_no() {
    while true; do
        read -p "$1 [y/n]: " yn
        case $yn in
            [Yy]*) return 0  ;;
            [Nn]*) return 1 ;;
        esac
    done
}

countdown() {
  for i in $(seq $1 -1 1); do
    echo $i
    sleep 1
  done;
}

# .env file must exist, otherwise exit
if ! [ -f "$CONF_FILE" ]; then
  echo "please create a file called '$CONF_FILE' in the current directory"
  exit 1
fi

export DISK
DISK="$(load_env_variable DISK)"
export POOL
POOL="$(load_env_variable POOL)"
export HOSTNAME
HOSTNAME="$(load_env_variable HOSTNAME)"
export TIMEZONE
TIMEZONE="$(load_env_variable TIMEZONE)"
export LOCALE
LOCALE="$(load_env_variable LOCALE)"
export KEYMAP
KEYMAP="$(load_env_variable KEYMAP)"
export CONSOLE_FONT
CONSOLE_FONT="$(load_env_variable CONSOLE_FONT)"
export USER_NAME
USER_NAME="$(load_env_variable USER_NAME)"
# maybe just read -rsp "Password: " USER_PASS
export USER_PASS
USER_PASS="$(load_env_variable USER_PASS)" # change after boot



# Logo generated by https://patorjk.com/software/taag/#p=display&f=ANSI%20Shadow&t=ZARCH
# Font Name: ANSI Shadow
printf "
----------------------------------------
███████╗ █████╗ ██████╗  ██████╗██╗  ██╗
╚══███╔╝██╔══██╗██╔══██╗██╔════╝██║  ██║
  ███╔╝ ███████║██████╔╝██║     ███████║
 ███╔╝  ██╔══██║██╔══██╗██║     ██╔══██║
███████╗██║  ██║██║  ██║╚██████╗██║  ██║
╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝
----------------------------------------
"

if ! [ -d /sys/firmware/efi ]; then
  echo "ERROR:"
  echo "zarch.sh does only work on modern EFI systems, you seem to use traditional BIOS"
  exit 1
fi


printf "The following config has been loaded:

DISK=%s
POOL=%s
HOSTNAME=%s
TIMEZONE=%s
LOCALE=%s
CONSOLE_FONT=%s
USER_NAME=%s
USER_PASS=%s

WARNING: If you proceed, your disk %s
will be COMPLETELY wiped and reformatted.
" "$DISK" "$POOL" "$HOSTNAME" "$TIMEZONE" "$LOCALE" "$CONSOLE_FONT" "$USER_NAME" "$USER_PASS" "$DISK"
yes_or_no "Are you sure?" || exit 0

echo "ok, let's go in"
countdown 5


# start script

# generate /etc/hostid (required by zfs)
[ -f /etc/hostid ] || RUN zgenhostid

# clear all PARTITIONS and create required ones
RUN sgdisk --zap-all $DISK
RUN sgdisk -n1:1M:+512M -t1:EF00 $DISK
RUN sgdisk -n2:0:0 -t2:BF00 $DISK
RUN sleep 1 # required, otherwise the pool creation fails

# create ZFS pool and datasets
# RUN not possible due to password prompt
next_cmd="zpool create -f -o ashift=12 -O compression=lz4 -O acltype=posixacl -O xattr=sa -O relatime=off -O atime=off -O encryption=aes-256-gcm -O keylocation=prompt -O keyformat=passphrase -o autotrim=on -m none $POOL ${DISK}-part2"
echo "$next_cmd"
# autoexpect: Enter new passphrase:
# autoexpect: Re-enter new passphrase:
zpool create -f -o ashift=12 -O compression=lz4 -O acltype=posixacl -O xattr=sa -O relatime=off -O atime=off -O encryption=aes-256-gcm -O keylocation=prompt -O keyformat=passphrase -o autotrim=on -m none $POOL ${DISK}-part2
CHECK_SUCCESS "$?" "$next_cmd"

RUN zfs create -o mountpoint=none "$POOL/ROOT"
RUN zfs create -o mountpoint=/ -o canmount=noauto "$POOL/ROOT/arch"
RUN zfs create -o mountpoint=/home "$POOL/home"

RUN zpool export "$POOL"

RUN zpool import -N -R /mnt "$POOL"
# RUN not possible due to password prompt
next_cmd="zfs load-key -L prompt $POOL"
echo "$next_cmd"
# autoexpect: Enter passphrase for 'rpool':
zfs load-key -L prompt "$POOL"
CHECK_SUCCESS "$?" "$next_cmd"
RUN zfs mount "$POOL/ROOT/arch"
RUN zfs mount "$POOL/home"

# create and mount EFI filesystem
RUN mkfs.vfat -F 32 -n EFI "$DISK-part1"
RUN mkdir /mnt/efi
RUN mount "$DISK-part1" /mnt/efi

# select fastest download mirror (significant speed improvements!)
iso=$(curl -4 ifconfig.co/country-iso)
next_cmd="pacman -Sy --noconfirm --needed reflector && reflector -a 48 -c \"$iso\" -f 5 -l 20 --sort rate --save /etc/pacman.d/mirrorlist"
echo "$next_cmd"
pacman -Sy --noconfirm --needed reflector \
    && cp /etc/pacman.d/mirrorlist /etc/pacman.d/mirrorlist.bak \
    && reflector -a 48 -c "$iso" -f 5 -l 20 --sort rate --save /etc/pacman.d/mirrorlist
CHECK_SUCCESS "$?" "$next_cmd"

# enable parallel downloads (faster)
RUN sed -i 's/^#ParallelDownloads/ParallelDownloads/' /etc/pacman.conf

# bootstrap base system into zfs filesystem under /mnt
echo "pacstrap /mnt base linux-lts linux-firmware linux-lts-headers efibootmgr zfs-dkms"
pacstrap /mnt base linux-lts linux-firmware linux-lts-headers efibootmgr zfs-dkms
CHECK_SUCCESS "$?" "pacstrap /mnt base linux-lts linux-firmware linux-lts-headers efibootmgr zfs-dkms"

# add normal user
# openssl passwd -6 -stdin seems to fail
# get mkpasswd instead
pacman -Sy whois
CRYPT_PASS="$(echo "$USER_PASS" | mkpasswd -s)"
RUN arch-chroot /mnt useradd -m -G wheel -s /usr/bin/zsh "$USER_NAME" -p "$CRYPT_PASS"
# RUN arch-chroot /mnt echo "$USER_NAME:$USER_PASS" | chpasswd

# bootstrap useful utilities
echo "grep -v '^\s*$\|^\s*#' $PKG_FILE | pacstrap /mnt -"
grep -v '^\s*$\|^\s*#' $PKG_FILE | pacstrap /mnt -
CHECK_SUCCESS "$?" "grep -v '^\s*$\|^\s*#' $PKG_FILE | pacstrap /mnt -"

RUN cp /etc/hostid /mnt/etc
RUN cp /etc/resolv.conf /mnt/etc
RUN cp /etc/pacman.conf /mnt/etc/pacman.conf

RUN genfstab /mnt | grep 'LABEL=EFI' -A 1 > /mnt/etc/fstab

# locale settings
RUN echo "LANG=$LOCALE" > /mnt/etc/locale.conf     # no need to define more than LANG - defaults the others
RUN sed -i "s/^#$LOCALE/$LOCALE/g" /mnt/etc/locale.gen
RUN echo "KEYMAP=$KEYMAP" > /mnt/etc/vconsole.conf

[ "$CONSOLE_FONT" = "" ] || RUN echo "FONT=$CONSOLE_FONT" >> /mnt/etc/vconsole.conf


RUN echo "$HOSTNAME" > /mnt/etc/hostname

RUN echo "# Static table lookup for hostnames." > /mnt/etc/hosts
RUN echo "# See hosts(5) for details." >> /mnt/etc/hosts
RUN echo "127.0.0.1   localhost" > /mnt/etc/hosts
RUN echo "::1   localhost" >> /mnt/etc/hosts
RUN echo "127.0.1.1   $HOSTNAME" >> /mnt/etc/hosts

# add zfs to mkinitcpio hooks
next_cmd="sed -i '/^HOOKS=/s/block filesystems/block zfs filesystems/g' /mnt/etc/mkinitcpio.conf"
echo "$next_cmd"
sed -i '/^HOOKS=/s/block filesystems/block zfs filesystems/g' /mnt/etc/mkinitcpio.conf
CHECK_SUCCESS "$?" "$next_cmd"

# configure all members of group wheel to have sudo
next_cmd="sed -i '/^# %wheel ALL=(ALL:ALL) ALL$/s/^# %wheel/%wheel/g' /mnt/etc/sudoers"
echo "$next_cmd"
sed -i '/^# %wheel ALL=(ALL:ALL) ALL$/s/^# %wheel/%wheel/g' /mnt/etc/sudoers
CHECK_SUCCESS "$?" "$next_cmd"

RUN arch-chroot /mnt hwclock --systohc
RUN arch-chroot /mnt timedatectl set-local-rtc 0
RUN arch-chroot /mnt locale-gen
RUN arch-chroot /mnt mkinitcpio -P
RUN arch-chroot /mnt zpool set cachefile=/etc/zfs/zpool.cache $POOL
RUN arch-chroot /mnt zpool set bootfs=$POOL/ROOT/arch $POOL
RUN arch-chroot /mnt systemctl enable zfs-import-cache zfs-import.target zfs-mount zfs-zed zfs.target
RUN arch-chroot /mnt mkdir -p /efi/EFI/zbm
RUN arch-chroot /mnt wget -c https://get.zfsbootmenu.org/latest.EFI -O /efi/EFI/zbm/zfsbootmenu.EFI
RUN arch-chroot /mnt efibootmgr --disk "$DISK" --part 1 --create --label "ZFSBootMenu" --loader '\EFI\zbm\zfsbootmenu.EFI' --unicode "spl_hostid=0x$(hostid) zbm.timeout=1 zbm.prefer=$POOL zbm.import_policy=hostid rd.vconsole.keymap=$KEYMAP rd.vconsole.font=$CONSOLE_FONT quiet" --verbose

next_cmd="arch-chroot /mnt zfs set org.zfsbootmenu:commandline="noresume init_on_alloc=0 rw spl.spl hostid="$(hostid)"" $POOL/ROOT"
echo "$next_cmd"
arch-chroot /mnt zfs set org.zfsbootmenu:commandline="noresume init_on_alloc=0 rw spl.spl hostid=$(hostid)" "$POOL/ROOT"
CHECK_SUCCESS "$?" "$next_cmd"


# enable services based on selected install packages
# exact word match is required, so no * is used in case
for pkg in $PKG_LIST; do
  s=""
  case "$pkg" in
    networkmanager)
      s="NetworkManager"
      ;;
    gnome)
      s="gdm"
      ;;
  esac

  [ "$s" = "" ] || RUN arch-chroot /mnt systemctl enable "$s"
done;




# build yay package as normal user (root does not work for makepkg)
# then install via pacman -U to prevent asking for password
RUN git clone https://aur.archlinux.org/yay-bin.git "/mnt/home/$USER_NAME/yay-bin"
RUN arch-chroot /mnt chown -R "$USER_NAME:$USER_NAME" "/home/$USER_NAME/yay-bin"
RUN arch-chroot /mnt su -c "makepkg -D /home/$USER_NAME/yay-bin -s" "$USER_NAME"
# RUN arch-chroot -u "$USER_NAME" /mnt makepkg -D "/home/$USER_NAME/yay-bin" -s

yay_pkg_file="$(find /mnt/home/sandreas/yay-bin/ -name 'yay-bin-*.pkg.tar.*' -not -name '*-debug-*' -exec basename {} \;)"
RUN arch-chroot /mnt pacman -U --noconfirm --needed "/home/$USER_NAME/yay-bin/$yay_pkg_file"

# install aur packages via yay
# RUN echo "$USER_NAME $HOSTNAME = NOPASSWD: /usr/bin/pacman" > /mnt/etc/sudoers.d/yay
# yay_script_file="/home/$USER_NAME/aurinstall.sh"
# cat <<EOF > "/mnt$yay_script_file"
# #!/bin/sh
# echo "$USER_PASS" | sudo -S echo ""
# yay --sudoloop --noconfirm --needed $(echo "$PKG_AUR_LIST" | tr '\n' ' ')
# EOF
# arch-chroot /mnt chmod +x "$yay_script_file"
# arch-chroot /mnt chown "$USER_NAME:$USER_NAME" "$yay_script_file"
# arch-chroot -u "$USER_NAME" /mnt "$yay_script_file"

arch-chroot -u "$USER_NAME" /mnt sudo -S touch /root/.bash_history <<< "$USER_PASS"
arch-chroot -u "$USER_NAME" /mnt yay -Sy --sudoloop --noconfirm --needed $(echo $PKG_AUR_LIST | tr '\n' ' ')


# RUN arch-chroot -u "$USER_NAME" /mnt "echo $USER_PASS | sudo -S echo \"\" && yay --sudoloop --noconfirm --needed $PKG_AUR_LIST"
# arch-chroot -u "$USER_NAME" /mnt echo "$USER_PASS"

for pkg in $PKG_AUR_LIST; do
  echo $pkg
done;


RUN umount /mnt/efi
RUN zpool export "$POOL"
